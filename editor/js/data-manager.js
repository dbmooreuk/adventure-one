/**
 * Data Manager - Handles import/export of gameData.js
 */

export class DataManager {
    constructor(editor) {
        this.editor = editor;
    }
    
    /**
     * Import gameData.js file
     */
    importData() {
        const fileInput = document.getElementById('file-input');
        fileInput.click();
    }
    
    /**
     * Handle file selection
     */
    async handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            const text = await file.text();
            const data = this.parseGameDataFile(text);
            
            if (data) {
                this.editor.loadData(data);
                this.editor.uiManager.setStatus(`Imported ${data.scenes.length} scenes and ${data.sceneItems.length} items`, 'success');
            }
        } catch (error) {
            console.error('Import error:', error);
            this.editor.uiManager.setStatus('Failed to import file: ' + error.message, 'danger');
        }
        
        // Reset file input
        event.target.value = '';
    }
    
    /**
     * Parse gameData.js file content
     */
    parseGameDataFile(text) {
        try {
            // Remove export statement and extract the object
            let cleaned = text.replace(/export\s+(const|let|var)\s+gameData\s*=\s*/, '');
            
            // Find the main object
            const objectStart = cleaned.indexOf('{');
            if (objectStart === -1) {
                throw new Error('Could not find gameData object');
            }
            
            // Extract just the object part (this is a simplified approach)
            // For production, you'd want a more robust parser
            cleaned = cleaned.substring(objectStart);
            
            // Remove trailing semicolon if present
            cleaned = cleaned.replace(/;?\s*$/, '');
            
            // Use Function constructor to safely evaluate the object
            // This is safer than eval but still requires trusted input
            const gameData = new Function('return ' + cleaned)();
            
            // Validate structure
            if (!gameData.scenes || !gameData.sceneItems) {
                throw new Error('Invalid gameData structure: missing scenes or sceneItems');
            }
            
            return gameData;
        } catch (error) {
            console.error('Parse error:', error);
            throw new Error('Failed to parse gameData.js: ' + error.message);
        }
    }
    
    /**
     * Export gameData.js file
     */
    exportData() {
        try {
            const content = this.generateGameDataFile();
            this.downloadFile('gameData.js', content);
            this.editor.uiManager.setStatus('Exported gameData.js successfully', 'success');
        } catch (error) {
            console.error('Export error:', error);
            this.editor.uiManager.setStatus('Failed to export: ' + error.message, 'danger');
        }
    }
    
    /**
     * Generate formatted gameData.js file content
     */
    generateGameDataFile() {
        const data = this.editor.data;
        
        let output = '/**\n';
        output += ' * Game Data Configuration\n';
        output += ' * Generated by Game Data Editor\n';
        output += ` * ${new Date().toISOString()}\n`;
        output += ' */\n\n';
        
        output += 'export const gameData = {\n';
        output += `    title: "${data.title}",\n`;
        output += `    version: "${data.version}",\n\n`;
        
        // Scenes
        output += '    scenes: [\n';
        data.scenes.forEach((scene, index) => {
            output += '        {\n';
            output += `            sceneName: "${scene.sceneName}",\n`;
            output += `            title: "${this.escapeString(scene.title)}",\n`;
            output += `            textOne: "${this.escapeString(scene.textOne)}",\n`;
            output += `            stage: "${scene.stage}",\n`;
            output += `            stageNumber: ${scene.stageNumber},\n`;
            output += `            sceneType: "${scene.sceneType}",\n`;
            
            if (scene.sceneMusic) {
                output += `            sceneMusic: "${scene.sceneMusic}",\n`;
            }

            if (scene.backgroundImage) {
                output += `            backgroundImage: "${scene.backgroundImage}",\n`;
            }

            if (scene.backgroundColor) {
                output += `            backgroundColor: "${scene.backgroundColor}",\n`;
            }
            
            if (scene.items && scene.items.length > 0) {
                output += `            items: [${scene.items.map(i => `"${i}"`).join(', ')}]`;
            } else {
                output += `            items: []`;
            }
            
            if (scene.locked) {
                output += `,\n            locked: true`;
                if (scene.unlockedBy) {
                    output += `,\n            unlockedBy: "${scene.unlockedBy}"`;
                }
            }
            
            if (scene.sceneType === 'puzzle') {
                if (scene.puzzleModule) {
                    output += `,\n            puzzleModule: "${scene.puzzleModule}"`;
                }
                if (scene.puzzleConfig) {
                    output += `,\n            puzzleConfig: ${JSON.stringify(scene.puzzleConfig, null, 12).replace(/\n/g, '\n            ')}`;
                }
            }
            
            output += '\n        }';
            if (index < data.scenes.length - 1) output += ',';
            output += '\n';
        });
        output += '    ],\n\n';
        
        // Scene Items
        output += '    sceneItems: [\n';
        data.sceneItems.forEach((item, index) => {
            output += this.formatItem(item, index < data.sceneItems.length - 1);
        });
        output += '    ],\n\n';

        // Audio
        if (data.audio) {
            output += '    audio: {\n';

            // Ambient music
            if (data.audio.ambient && Object.keys(data.audio.ambient).length > 0) {
                output += '        ambient: {\n';
                const ambientEntries = Object.entries(data.audio.ambient);
                ambientEntries.forEach(([key, value], index) => {
                    const valueStr = value === null ? 'null' : `"${value}"`;
                    output += `            ${key}: ${valueStr}`;
                    if (index < ambientEntries.length - 1) output += ',';
                    output += '\n';
                });
                output += '        }';
                if (data.audio.sounds && Object.keys(data.audio.sounds).length > 0) {
                    output += ',';
                }
                output += '\n';
            }

            // Sound effects
            if (data.audio.sounds && Object.keys(data.audio.sounds).length > 0) {
                output += '        sounds: {\n';
                const soundEntries = Object.entries(data.audio.sounds);
                soundEntries.forEach(([key, value], index) => {
                    const valueStr = value === null ? 'null' : `"${value}"`;
                    output += `            ${key}: ${valueStr}`;
                    if (index < soundEntries.length - 1) output += ',';
                    output += '\n';
                });
                output += '        }\n';
            }

            output += '    }\n';
        }

        output += '};\n';

        return output;
    }
    
    /**
     * Format a single item
     */
    formatItem(item, addComma) {
        let output = '        {\n';
        
        // Basic properties
        output += `            name: "${item.name}",\n`;
        output += `            longName: "${this.escapeString(item.longName)}",\n`;
        if (item.shortName) output += `            shortName: "${this.escapeString(item.shortName)}",\n`;
        output += `            type: "${item.type}",\n`;
        output += `            lookAt: "${this.escapeString(item.lookAt)}",\n`;
        
        // Type-specific properties
        if (item.pickUpMessage) output += `            pickUpMessage: ${item.pickUpMessage === null ? 'null' : `"${this.escapeString(item.pickUpMessage)}"`},\n`;
        if (item.useWith) output += `            useWith: "${item.useWith}",\n`;
        if (item.useMessage) output += `            useMessage: "${this.escapeString(item.useMessage)}",\n`;
        if (item.useResult) output += `            useResult: "${item.useResult}",\n`;

        // Combine properties
        if (item.combineWith) output += `            combineWith: "${item.combineWith}",\n`;
        if (item.combineResult) output += `            combineResult: "${item.combineResult}",\n`;
        if (item.combineMessage) output += `            combineMessage: "${this.escapeString(item.combineMessage)}",\n`;
        if (item.combinePoints !== undefined && item.combinePoints !== null) {
            output += `            combinePoints: ${item.combinePoints},\n`;
        }

        // Handle outcome - can be string or array
        if (item.outcome) {
            if (Array.isArray(item.outcome)) {
                output += `            outcome: [${item.outcome.map(o => `"${o}"`).join(', ')}],\n`;
            } else {
                output += `            outcome: "${item.outcome}",\n`;
            }
        }

        if (item.linkToScene) output += `            linkToScene: "${item.linkToScene}",\n`;
        if (item.nextScene) output += `            nextScene: "${item.nextScene}",\n`;
        if (item.lockedMessage) output += `            lockedMessage: "${this.escapeString(item.lockedMessage)}",\n`;
        
        // Points
        if (item.points !== undefined && item.points !== null) {
            output += `            points: ${item.points},\n`;
        }
        
        // Visual properties
        if (item.image) output += `            image: "${item.image}",\n`;
        if (item.position) output += `            position: [${item.position[0]}, ${item.position[1]}],\n`;
        if (item.size) output += `            size: [${item.size[0]}, ${item.size[1]}],\n`;
        if (item.hitW) output += `            hitW: ${item.hitW},\n`;
        if (item.hitH) output += `            hitH: ${item.hitH},\n`;
        if (item.hitPolygon && item.hitPolygon.length > 0) {
            output += `            hitPolygon: [\n`;
            item.hitPolygon.forEach((point, index) => {
                const isLast = index === item.hitPolygon.length - 1;
                output += `                [${point[0]}, ${point[1]}]${isLast ? '' : ','}\n`;
            });
            output += `            ],\n`;
        }
        if (item.zIndex !== undefined && item.zIndex !== null) {
            console.log(`ðŸ“¦ Exporting z-index for ${item.name}:`, item.zIndex);
            output += `            zIndex: ${item.zIndex},\n`;
        }
        if (item.nonInteractive) output += `            nonInteractive: true,\n`;

        // Animation
        if (item.animation) {
            output += `            animation: ${JSON.stringify(item.animation, null, 16).replace(/\n/g, '\n            ')},\n`;
        }
        
        // Effects
        if (item.onClickEffect) output += `            onClickEffect: "${item.onClickEffect}",\n`;
        if (item.onClickSound) output += `            onClickSound: "${item.onClickSound}",\n`;
        
        // Style
        if (item.style) {
            output += `            style: ${JSON.stringify(item.style, null, 16).replace(/\n/g, '\n            ')}\n`;
        } else {
            // Remove trailing comma from last property
            output = output.replace(/,\n$/, '\n');
        }
        
        output += '        }';
        if (addComma) output += ',';
        output += '\n';
        
        return output;
    }
    
    /**
     * Escape special characters in strings
     */
    escapeString(str) {
        if (!str) return '';
        return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
    }
    
    /**
     * Download file to user's computer
     */
    downloadFile(filename, content) {
        const blob = new Blob([content], { type: 'text/javascript' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
}

