/**
 * Data Manager - Handles import/export of gameData.js
 */

export class DataManager {
    constructor(editor) {
        this.editor = editor;
    }
    
    /**
     * Import gameData.js file
     */
    importData() {
        const fileInput = document.getElementById('file-input');
        fileInput.click();
    }
    
    /**
     * Handle file selection
     */
    async handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            const text = await file.text();
            const data = this.parseGameDataFile(text);
            
            if (data) {
                this.editor.loadData(data);
                this.editor.uiManager.setStatus(`Imported ${data.scenes.length} scenes and ${data.sceneItems.length} items`, 'success');
            }
        } catch (error) {
            console.error('Import error:', error);
            this.editor.uiManager.setStatus('Failed to import file: ' + error.message, 'danger');
        }
        
        // Reset file input
        event.target.value = '';
    }
    
    /**
     * Parse gameData.js file content
     */
    parseGameDataFile(text) {
        try {
            // Remove export statement and extract the object
            let cleaned = text.replace(/export\s+(const|let|var)\s+gameData\s*=\s*/, '');
            
            // Find the main object
            const objectStart = cleaned.indexOf('{');
            if (objectStart === -1) {
                throw new Error('Could not find gameData object');
            }
            
            // Extract just the object part (this is a simplified approach)
            // For production, you'd want a more robust parser
            cleaned = cleaned.substring(objectStart);
            
            // Remove trailing semicolon if present
            cleaned = cleaned.replace(/;?\s*$/, '');
            
            // Use Function constructor to safely evaluate the object
            // This is safer than eval but still requires trusted input
            const gameData = new Function('return ' + cleaned)();
            
            // Validate structure
            if (!gameData.scenes || !gameData.sceneItems) {
                throw new Error('Invalid gameData structure: missing scenes or sceneItems');
            }
            
            return gameData;
        } catch (error) {
            console.error('Parse error:', error);
            throw new Error('Failed to parse gameData.js: ' + error.message);
        }
    }
    
    /**
     * Export gameData.js file
     */
    exportData() {
        try {
            const content = this.generateGameDataFile();
            this.downloadFile('gameData.js', content);
            this.editor.uiManager.setStatus('Exported gameData.js successfully', 'success');
        } catch (error) {
            console.error('Export error:', error);
            this.editor.uiManager.setStatus('Failed to export: ' + error.message, 'danger');
        }
    }
    
    /**
     * Generate formatted gameData.js file content
     */
    generateGameDataFile() {
        console.log('ðŸ“¦ generateGameDataFile() called');
        const data = this.editor.data;
        console.log('ðŸ“¦ Editor data:', data);

        if (!data) {
            console.error('âŒ No editor data available!');
            return '';
        }

        let output = '/**\n';
        output += ' * Game Data Configuration\n';
        output += ' * Generated by Game Data Editor\n';
        output += ` * ${new Date().toISOString()}\n`;
        output += ' */\n\n';

        output += 'export const gameData = {\n';
        output += `    title: "${data.title || 'Untitled'}",\n`;
        output += `    version: "${data.version || '1.0.0'}",\n\n`;
        
        // Scenes
        output += '    scenes: [\n';
        data.scenes.forEach((scene, index) => {
            output += '        {\n';
            output += `            sceneName: "${scene.sceneName}",\n`;
            output += `            title: "${this.escapeString(scene.title)}",\n`;
            output += `            textOne: "${this.escapeString(scene.textOne)}",\n`;
            output += `            stage: "${scene.stage}",\n`;
            output += `            stageNumber: ${scene.stageNumber},\n`;
            output += `            sceneType: "${scene.sceneType}",\n`;
            
            if (scene.sceneMusic) {
                output += `            sceneMusic: "${scene.sceneMusic}",\n`;
            }

            if (scene.backgroundImage) {
                output += `            backgroundImage: "${scene.backgroundImage}",\n`;
            }

            if (scene.backgroundColor) {
                output += `            backgroundColor: "${scene.backgroundColor}",\n`;
            }
            
            if (scene.items && scene.items.length > 0) {
                output += `            items: [${scene.items.map(i => `"${i}"`).join(', ')}]`;
            } else {
                output += `            items: []`;
            }
            
            if (scene.locked) {
                output += `,\n            locked: true`;
                if (scene.unlockedBy) {
                    output += `,\n            unlockedBy: "${scene.unlockedBy}"`;
                }
            }
            
            if (scene.sceneType === 'puzzle') {
                if (scene.puzzleModule) {
                    output += `,\n            puzzleModule: "${scene.puzzleModule}"`;
                }
                if (scene.puzzleConfig) {
                    output += `,\n            puzzleConfig: ${JSON.stringify(scene.puzzleConfig, null, 12).replace(/\n/g, '\n            ')}`;
                }
                if (scene.puzzleWidth) {
                    output += `,\n            puzzleWidth: ${scene.puzzleWidth}`;
                }
                if (scene.puzzleHeight) {
                    output += `,\n            puzzleHeight: ${scene.puzzleHeight}`;
                }
                if (scene.puzzleTop !== undefined && scene.puzzleTop !== null) {
                    output += `,\n            puzzleTop: ${scene.puzzleTop}`;
                }
                if (scene.puzzleLeft !== undefined && scene.puzzleLeft !== null) {
                    output += `,\n            puzzleLeft: ${scene.puzzleLeft}`;
                }
                if (scene.puzzleRight !== undefined && scene.puzzleRight !== null) {
                    output += `,\n            puzzleRight: ${scene.puzzleRight}`;
                }
                if (scene.puzzleBottom !== undefined && scene.puzzleBottom !== null) {
                    output += `,\n            puzzleBottom: ${scene.puzzleBottom}`;
                }
            }

            if (scene.achievement) {
                output += `,\n            achievement: "${this.escapeString(scene.achievement)}"`;
            }

            if (scene.points !== undefined && scene.points !== null) {
                output += `,\n            points: ${scene.points}`;
            }

            output += '\n        }';
            if (index < data.scenes.length - 1) output += ',';
            output += '\n';
        });
        output += '    ],\n\n';
        
        // Scene Items
        output += '    sceneItems: [\n';
        data.sceneItems.forEach((item, index) => {
            output += this.formatItem(item, index < data.sceneItems.length - 1);
        });
        output += '    ],\n\n';

        // Audio
        if (data.audio) {
            output += '    audio: {\n';

            // Ambient music
            if (data.audio.ambient && Object.keys(data.audio.ambient).length > 0) {
                output += '        ambient: {\n';
                const ambientEntries = Object.entries(data.audio.ambient);
                ambientEntries.forEach(([key, value], index) => {
                    const valueStr = value === null ? 'null' : `"${value}"`;
                    output += `            ${key}: ${valueStr}`;
                    if (index < ambientEntries.length - 1) output += ',';
                    output += '\n';
                });
                output += '        }';
                if (data.audio.sounds && Object.keys(data.audio.sounds).length > 0) {
                    output += ',';
                }
                output += '\n';
            }

            // Sound effects
            if (data.audio.sounds && Object.keys(data.audio.sounds).length > 0) {
                output += '        sounds: {\n';
                const soundEntries = Object.entries(data.audio.sounds);
                soundEntries.forEach(([key, value], index) => {
                    const valueStr = value === null ? 'null' : `"${value}"`;
                    output += `            ${key}: ${valueStr}`;
                    if (index < soundEntries.length - 1) output += ',';
                    output += '\n';
                });
                output += '        }\n';
            }

            output += '    }\n';
        }

        output += '};\n';

        return output;
    }
    
    /**
     * Format a single item
     */
    formatItem(item, addComma) {
        let output = '        {\n';
        
        // Mandatory properties (all items)
        output += `            name: "${item.name}",\n`;
        output += `            longName: "${this.escapeString(item.longName)}",\n`;
        if (item.shortName) output += `            shortName: "${this.escapeString(item.shortName)}",\n`;
        output += `            type: "${item.type}",\n`;

        // lookAt is mandatory for all except decor
        if (item.type !== 'decor' && item.lookAt) {
            output += `            lookAt: "${this.escapeString(item.lookAt)}",\n`;
        }
        
        // Type-specific mandatory properties
        // pickUpMessage is mandatory for item, target, link
        if (['item', 'target', 'link'].includes(item.type) && item.pickUpMessage) {
            output += `            pickUpMessage: ${item.pickUpMessage === null ? 'null' : `"${this.escapeString(item.pickUpMessage)}"`},\n`;
        }

        // useWith is mandatory for item, target, link
        if (['item', 'target', 'link'].includes(item.type) && item.useWith) {
            output += `            useWith: "${item.useWith}",\n`;
        }

        // useMessage is mandatory for target
        if (item.type === 'target' && item.useMessage) {
            output += `            useMessage: "${this.escapeString(item.useMessage)}",\n`;
        }

        // useResult is mandatory for target
        if (item.type === 'target' && item.useResult) {
            output += `            useResult: "${item.useResult}",\n`;
        }

        // Combine properties
        if (item.combineWith) output += `            combineWith: "${item.combineWith}",\n`;
        if (item.combineResult) output += `            combineResult: "${item.combineResult}",\n`;
        if (item.combineMessage) output += `            combineMessage: "${this.escapeString(item.combineMessage)}",\n`;
        if (item.combinePoints !== undefined && item.combinePoints !== null) {
            output += `            combinePoints: ${item.combinePoints},\n`;
        }

        // outcome is mandatory for item, target, link
        if (['item', 'target', 'link'].includes(item.type) && item.outcome) {
            if (Array.isArray(item.outcome)) {
                output += `            outcome: [${item.outcome.map(o => `"${o}"`).join(', ')}],\n`;
            } else {
                output += `            outcome: "${item.outcome}",\n`;
            }
        }

        // linkToScene is mandatory for link
        if (item.type === 'link' && item.linkToScene) {
            output += `            linkToScene: "${item.linkToScene}",\n`;
        }

        // Optional fields
        if (item.nextScene) output += `            nextScene: "${item.nextScene}",\n`;
        if (item.lockedMessage) output += `            lockedMessage: "${this.escapeString(item.lockedMessage)}",\n`;
        
        // Points (optional for item, target, link, decor)
        if (item.points !== undefined && item.points !== null) {
            output += `            points: ${item.points},\n`;
        }

        // Achievement (optional for item, target, link, decor, character)
        if (item.achievement) {
            output += `            achievement: "${this.escapeString(item.achievement)}",\n`;
        }

        // Character-specific quiz fields
        if (item.type === 'character') {
            if (item.question) {
                output += `            question: "${this.escapeString(item.question)}",\n`;
            }
            if (item.answers && Array.isArray(item.answers) && item.answers.length > 0) {
                output += `            answers: [\n`;
                item.answers.forEach((answer, index) => {
                    const isLast = index === item.answers.length - 1;
                    output += `                { text: "${this.escapeString(answer.text)}", isCorrect: ${answer.isCorrect} }${isLast ? '' : ','}\n`;
                });
                output += `            ],\n`;
            }
            if (item.correctMessage) {
                output += `            correctMessage: "${this.escapeString(item.correctMessage)}",\n`;
            }
            if (item.incorrectMessage) {
                output += `            incorrectMessage: "${this.escapeString(item.incorrectMessage)}",\n`;
            }
            if (item.reward) {
                output += `            reward: "${item.reward}",\n`;
            }
            if (item.outcome) {
                if (Array.isArray(item.outcome)) {
                    output += `            outcome: [${item.outcome.map(o => `"${o}"`).join(', ')}],\n`;
                } else {
                    output += `            outcome: "${item.outcome}",\n`;
                }
            }
        }

        // Mandatory visual properties (all items)
        // Image is always required
        if (item.image) {
            output += `            image: "${item.image}",\n`;
        }

        // Position is always required
        if (item.position) {
            output += `            position: [${item.position[0]}, ${item.position[1]}],\n`;
        }

        // Size is always required
        if (item.size) {
            output += `            size: [${item.size[0]}, ${item.size[1]}],\n`;
        }

        // zIndex is always required
        if (item.zIndex !== undefined && item.zIndex !== null) {
            output += `            zIndex: ${item.zIndex},\n`;
        }

        // Hit area - required for item/target/link (either hitPolygon OR hitW/hitH)
        if (['item', 'target', 'link'].includes(item.type)) {
            if (item.hitPolygon && Array.isArray(item.hitPolygon) && item.hitPolygon.length > 0) {
                output += `            hitPolygon: [\n`;
                item.hitPolygon.forEach((point, index) => {
                    const isLast = index === item.hitPolygon.length - 1;
                    output += `                [${point[0]}, ${point[1]}]${isLast ? '' : ','}\n`;
                });
                output += `            ],\n`;
            } else if (item.hitPolygon && typeof item.hitPolygon === 'object' && !Array.isArray(item.hitPolygon)) {
                // Handle case where hitPolygon is an object (from IndexedDB)
                // Convert object to array
                const polygonArray = Object.values(item.hitPolygon);
                if (polygonArray.length > 0) {
                    output += `            hitPolygon: [\n`;
                    polygonArray.forEach((point, index) => {
                        const isLast = index === polygonArray.length - 1;
                        output += `                [${point[0]}, ${point[1]}]${isLast ? '' : ','}\n`;
                    });
                    output += `            ],\n`;
                }
            } else if (item.hitW !== undefined && item.hitH !== undefined) {
                output += `            hitW: ${item.hitW},\n`;
                output += `            hitH: ${item.hitH},\n`;
            }
        }

        // Optional: nonInteractive for decor
        if (item.type === 'decor' && item.nonInteractive) {
            output += `            nonInteractive: true,\n`;
        }

        // Animation
        if (item.animation) {
            output += `            animation: ${JSON.stringify(item.animation, null, 16).replace(/\n/g, '\n            ')},\n`;
        }
        
        // Effects
        if (item.onClickEffect) output += `            onClickEffect: "${item.onClickEffect}",\n`;
        if (item.onClickSound) output += `            onClickSound: "${item.onClickSound}",\n`;
        
        // Style
        if (item.style) {
            output += `            style: ${JSON.stringify(item.style, null, 16).replace(/\n/g, '\n            ')}\n`;
        } else {
            // Remove trailing comma from last property
            output = output.replace(/,\n$/, '\n');
        }
        
        output += '        }';
        if (addComma) output += ',';
        output += '\n';
        
        return output;
    }
    
    /**
     * Escape special characters in strings
     */
    escapeString(str) {
        if (!str) return '';
        return str
            .replace(/\\/g, '\\\\')
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
    }
    
    /**
     * Download file to user's computer
     */
    downloadFile(filename, content) {
        const blob = new Blob([content], { type: 'text/javascript' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
}

